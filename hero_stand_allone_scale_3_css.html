<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hero</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,900;1,600&display=swap" rel="stylesheet">
<style>
  /* =========================================================
     Signature Hero – Kommentar-Doku (Kurzfassung)
     Zweck: Wiederkehrender Hero mit "BRAND" + AI-Overlay + Tagline + Subline.
     Override-Priorität: inline am Wrapper (.hero-section) > Regel (.hero-section) > :root.
     Instanz-Steuerung: nur Variablen setzen/überschreiben – niemals Struktur ändern.
     Pflege: Kommentare NICHT entfernen, sie dokumentieren Stellschrauben.
  ========================================================= */
  :root {
    --bg1: #123f87;  /* Hintergrund Verlauf - Start */
    --bg2: #8b2570;  /* Hintergrund Verlauf - Ende  */

    --t1: #207cfa;   /* BRAND */
    --t2: #ff3cd0;   /* AI + Tagline */

    /* === FEINJUSTAGE === */
    /* BRAND-Größe (wirkt auch auf AI-Ausrichtung): */
    --brandMin: 3.25rem;  /* kleinste Größe */
    --brandVW: 14vw;      /* Skalierung über Viewport */
    --brandMax: 8rem;     /* Obergrenze */

    /* AI-Ausrichtung relativ zum A in BRAND (em-basiert) */
    --aiOffsetX: 0.0em;   /* horizontal */
    --aiOffsetY: 0.11em;  /* vertikal   */

    /* Tagline-Position relativ zu BRAND (links/oben) */
    --tagOffsetX: 0.05em; /* <0=links, >0=rechts */
    --tagOffsetY: 0.13em; /* <0=hoch,  >0=runter */

    /* Subline-Position relativ zu BRAND (links/unten) */
    --subOffsetX: 0.06em; /* <0=links, >0=rechts */
    --subOffsetY: -0.05em;/* <0=hoch,  >0=runter */

    /* Subline-Laufweite und Mindestabstand zwischen Worten (global) */
    --subTracking: 0.01em; /* 0.00–0.03 em empfohlen */
    --subMinGap: 0.1ch;

    /* Schriftgrößen (rein per CSS, ohne JS-Kopplung) */
    --typeScale: 2;             /* globaler Typo-Faktor */
    --tagMin: 1rem; --tagVW: 3.5vw; --tagMax: 2rem;        /* Tagline Größe */
    --subMin: 0.82rem; --subVW: 1.9vw; --subMax: 1.1rem;

    /* >>> Mobile-Only Skalierung (Standard = 1). In @media wird überschrieben. */
    --tagMobileScale: 1; /* MOBIL: Tagline-Skalierung (1=100%) */
    --subMobileScale: 1; /* MOBIL: Subline-Skalierung (1=100%) */   /* Subline Größe */
  }

  * { box-sizing: border-box; }
  html, body { margin: 0; height: 100%; }
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(135deg, var(--bg1), var(--bg2));
    font-family: 'Montserrat', sans-serif;
  }

  .hero {
    position: relative;
    text-align: center;
    width: min(90vw, 700px);
    height: min(100vh, 800px);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    opacity: 0;              /* Startzustand: unsichtbar */
    will-change: opacity;    /* Performance-Hinweis */
  }

  .text-layer {
    line-height: 1;
    letter-spacing: 0em;
    font-weight: 900;
    font-size: clamp(3rem, 10vw, 8rem);
    margin: 0;
    white-space: nowrap;
  }

  .tagline {
    position: absolute;
    left: 0; top: 0;
    margin: 0;
    font-weight: 900;
    /* globaler Typo-Faktor */
    font-size: calc(clamp(var(--tagMin), var(--tagVW), var(--tagMax)) * var(--typeScale) * var(--tagMobileScale)); /* MOBIL-Regler: --tagMobileScale */
    color: var(--t2);
    letter-spacing: 0em;
    line-height: 1.1;
    white-space: nowrap; /* KEINE Umbrüche – wiederkehrendes Visual */
    z-index: 3;
    pointer-events: none;
  }

  .subline {
    position: absolute;
    left: 0; top: 0;
    margin: 0;
    font-weight: 600;      /* Semibold */
    font-style: italic;    /* Italic */
    /* globaler Typo-Faktor */
    font-size: calc(clamp(var(--subMin), var(--subVW), var(--subMax)) * var(--typeScale) * var(--subMobileScale)); /* MOBIL-Regler: --subMobileScale */
    color: #fff;           /* Weiß */
    letter-spacing: var(--subTracking); /* leichte Laufweite für Buchstaben */
    line-height: 1.2;
    white-space: nowrap;   /* immer eine Zeile */
    display: flex;         /* verteilt die drei Begriffe */
    flex-wrap: nowrap;
    justify-content: space-between; /* füllt die vorgegebene Breite */
    column-gap: var(--subMinGap);   /* Mindestabstand zwischen Items */
    text-align: left;
    z-index: 2;
    pointer-events: none;  /* später für Interaktion entfernen */
  }
  .subline > span { display: inline-block; }

  .brand {
    color: var(--t1);
    /* BRAND-Größe: hier über CSS-Variablen steuerbar */
    /* globaler Typo-Faktor wirkt hier mit */
    font-size: calc(clamp(var(--brandMin), var(--brandVW), var(--brandMax)) * var(--typeScale));
  }

  .ai {
    position: absolute;
    left: 0; /* feste Referenz (Container: .hero) */
    top: 0;
    color: var(--t2);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.8s ease;
  }
  .ai.show { opacity: 1; }

  /* Gesamter Hero fadet ein */
  .hero.show { animation: fadeInHero 0.7s ease forwards; }
  @keyframes fadeInHero { to { opacity: 1; } }

  /* Mobile: BRAND etwas größer skalieren, um den Raum besser zu nutzen */
  @media (max-width: 600px) {
    :root {
      /* ===== MOBILE-SKALIERUNG (einfach, prozentual) =====
         Tagline -10%  → --tagMobileScale: 0.90
         Subline -20%  → --subMobileScale: 0.80
         => Werte hier ändern, wenn du andere Prozente willst. */
      --tagMobileScale: 0.90; /* -10% */
      --subMobileScale: 0.80; /* -20% */

      /* BRAND mobil etwas breiter, ohne zu bluten */
      /* BRAND mobil etwas breiter, ohne zu bluten */
      --brandMin: 3.6rem;
      --brandVW: 20vw;

      /* MOBILE A/B-Punkte + Steigung (Tagline)
         A = --tagMin (kleinstes), B = --tagMax (größtes),
         dazwischen steuert --tagVW die Steigung */
      --tagMin: 0.9rem;  /* A */
      --tagVW: 2.8vw;    /* Steigung */
      --tagMax: 1.25rem; /* B */

      /* MOBILE A/B-Punkte + Steigung (Subline) */
      --subMin: 0.58rem; /* A */
      --subVW: 2.1vw;    /* Steigung */
      --subMax: 0.80rem; /* B */

      /* Etwas engere Abstände/Laufweite für Mobile */
      --subMinGap: 0.08ch;
      --subTracking: 0.008em;
    }
  }
</style>
</head>
<body>
  <div class="hero" id="hero">
    <p class="tagline" id="tagline">SHAPE YOUR BRAND</p>
    <h1 class="text-layer brand" id="brand">BRAND<span id="ai" class="ai">AI</span></h1>
    <!-- SUBLINE:
         • Begriffe direkt in den <span>-Tags ändern.
         • Mindestabstand zwischen Items: :root --subMinGap
         • Laufweite (Buchstaben): :root --subTracking
         • Immer eine Zeile; Breite wird per JS exakt an BRAND-Text angepasst. -->
    <p class="subline" id="subline" aria-label="BRANDSTRATEGY BRANDDESIGN AI-WORKFLOW">
      <span data-key="strategy">BRANDSTRATEGY</span>
      <span data-key="design">BRANDDESIGN</span>
      <span data-key="ai">AI&#8209;WORKFLOW</span>
    </p>
  </div>

<script>
  (function(){
    const hero=document.getElementById('hero');
    const brand=document.getElementById('brand');
    const ai=document.getElementById('ai');
    const tagline=document.getElementById('tagline');
    const subline=document.getElementById('subline');

    /* Mobile: BRAND ~96% Breite, verhindert "Bluten" */
    function sizeBrandTo(ratio=0.96){
      const small=matchMedia('(max-width:600px)').matches;
      if(!small){ brand.style.fontSize=''; return; }
      const h=hero.getBoundingClientRect(); if(!h.width) return;
      brand.style.fontSize='';
      const cs=getComputedStyle(brand), fs=parseFloat(cs.fontSize)||1;
      const w=brand.getBoundingClientRect().width||1;
      brand.style.fontSize=(fs*(h.width*ratio/w))+'px';
    }

    /* Einfache Positions-Ausrichtung – keine Größen-/Breitenkopplungen */
    function alignPositions(){
      const cs=getComputedStyle(brand); const fs=parseFloat(cs.fontSize)||1;

      // AI-Overlay an das "A" in BRAND ausrichten
      const text=brand.firstChild; if(!(text&&text.nodeType===3)) return;
      const idxA=brand.textContent.indexOf('A'); if(idxA===-1) return;
      const rA=document.createRange(); rA.setStart(text,idxA); rA.setEnd(text,idxA+1);

      const aRect=rA.getBoundingClientRect();
      const heroRect=hero.getBoundingClientRect();
      const brandRect=brand.getBoundingClientRect();

      const root=getComputedStyle(document.documentElement);
      const aiX=(parseFloat(root.getPropertyValue('--aiOffsetX'))||0)*fs;
      const aiY=(parseFloat(root.getPropertyValue('--aiOffsetY'))||0)*fs;
      ai.style.left=(aRect.left-heroRect.left+aiX)+'px';
      ai.style.top =(aRect.top -heroRect.top +aiY)+'px';

      // Tagline oben über BRAND positionieren (Größe rein aus CSS)
      const tagX=(parseFloat(root.getPropertyValue('--tagOffsetX'))||0)*fs;
      const tagY=(parseFloat(root.getPropertyValue('--tagOffsetY'))||0)*fs;
      const tagRect=tagline.getBoundingClientRect();
      tagline.style.left=(brandRect.left-heroRect.left+tagX)+'px';
      tagline.style.top =(brandRect.top -heroRect.top -tagRect.height+tagY)+'px';

      // Subline unter BRAND positionieren (Größe rein aus CSS)
      const subX=(parseFloat(root.getPropertyValue('--subOffsetX'))||0)*fs;
      const subY=(parseFloat(root.getPropertyValue('--subOffsetY'))||0)*fs;
      subline.style.left=(brandRect.left-heroRect.left+subX)+'px';
      subline.style.top =(brandRect.bottom-heroRect.top+subY)+'px';
      subline.style.whiteSpace='nowrap';
    }

    function run(){ sizeBrandTo(0.96); alignPositions(); }

    function init(){
      run();
      // Minimal-Checks (nur Hinweis in Konsole, kein Eingriff)
      setTimeout(()=>{
        try{
          console.assert(tagline.scrollWidth<=document.getElementById('hero').clientWidth,'Tagline overflow');
          console.assert(subline.scrollWidth<=document.getElementById('hero').clientWidth,'Subline overflow');
        }catch(e){}
      },100);
      hero.classList.add('show');
      setTimeout(()=>ai.classList.add('show'),1400);
    }

    if(document.fonts && document.fonts.ready){ document.fonts.ready.then(init); }
    else{ window.addEventListener('load', init); }

    window.addEventListener('resize', run);
    new ResizeObserver(run).observe(hero);
  })();
</script>
</body>
</html>
