<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hero</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,900;1,600&display=swap" rel="stylesheet">
<style>
  /* =========================================================
     Signature Hero – Kommentar-Doku (Kurzfassung)
     Zweck: Wiederkehrender Hero mit "BRAND" + AI-Overlay + Tagline + Subline.
     Override-Priorität: inline am Wrapper (.hero-section) > Regel (.hero-section) > :root.
     Instanz-Steuerung: nur Variablen setzen/überschreiben – niemals Struktur ändern.
     Pflege: Kommentare NICHT entfernen, sie dokumentieren Stellschrauben.
  ========================================================= */
  :root {
    --bg1: #123f87;  /* Hintergrund Verlauf - Start */
    --bg2: #8b2570;  /* Hintergrund Verlauf - Ende  */

    --t1: #207cfa;   /* BRAND */
    --t2: #ff3cd0;   /* AI + Tagline */

    /* === FEINJUSTAGE === */
    /* BRAND-Größe (wirkt auch auf AI-Ausrichtung): */
    --brandMin: 3.25rem;  /* kleinste Größe */
    --brandVW: 14vw;      /* Skalierung über Viewport */
    --brandMax: 8rem;     /* Obergrenze */

    /* AI-Ausrichtung relativ zum A in BRAND (em-basiert) */
    --aiOffsetX: 0.0em;   /* horizontal */
    --aiOffsetY: 0.11em;  /* vertikal   */

    /* Tagline-Position relativ zu BRAND (links/oben) */
    --tagOffsetX: 0.05em; /* <0=links, >0=rechts */
    --tagOffsetY: 0.13em; /* <0=hoch,  >0=runter */

    /* Subline-Position relativ zu BRAND (links/unten) */
    --subOffsetX: 0.06em; /* Feintuning: nach rechts verschieben */    /* <0=links, >0=rechts */
    --subOffsetY: -0.05em;/* <0=hoch,  >0=runter */

    /* Subline-Laufweite und Mindestabstand zwischen Worten (global) */
    --subTracking: 0.01em; /* 0.00–0.03 em empfohlen */
    --subMinGap: 0.1ch;
    --subWidthFactor: 0.98; /* Desktop: Anteil der BRAND-Textbreite */
    --typeScale: 1.6; /* GLOBALER Typo-Faktor: skaliert BRAND, Tagline, Subline zentral */
  }

  * { box-sizing: border-box; }
  html, body { margin: 0; height: 100%; }
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(135deg, var(--bg1), var(--bg2));
    font-family: 'Montserrat', sans-serif;
  }

  .hero {
    position: relative;
    text-align: center;
    width: min(90vw, 700px);
    height: min(100vh, 800px);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    opacity: 0;              /* Startzustand: unsichtbar */
    will-change: opacity;    /* Performance-Hinweis */
  }

  .text-layer {
    line-height: 1;
    letter-spacing: 0em;
    font-weight: 900;
    font-size: clamp(3rem, 10vw, 8rem);
    margin: 0;
    white-space: nowrap;
  }

  .tagline {
    position: absolute;
    left: 0; top: 0;
    margin: 0;
    font-weight: 900;
    /* globaler Typo-Faktor */
    font-size: calc(clamp(1rem, 3.5vw, 2rem) * var(--typeScale));
    color: var(--t2);
    letter-spacing: 0em;
    line-height: 1.1;
    white-space: nowrap; /* KEINE Umbrüche – wiederkehrendes Visual */
    z-index: 3;
    pointer-events: none;
  }

  .subline {
    position: absolute;
    left: 0; top: 0;
    margin: 0;
    font-weight: 600;      /* Semibold */
    font-style: italic;    /* Italic */
    /* globaler Typo-Faktor */
    font-size: calc(clamp(0.7rem, 1.6vw, 0.95rem) * var(--typeScale));
    color: #fff;           /* Weiß */
    letter-spacing: var(--subTracking); /* leichte Laufweite für Buchstaben */
    line-height: 1.2;
    white-space: nowrap;   /* immer eine Zeile */
    display: flex;         /* verteilt die drei Begriffe */
    flex-wrap: nowrap;
    justify-content: space-between; /* füllt die vorgegebene Breite */
    column-gap: var(--subMinGap);   /* Mindestabstand zwischen Items */
    text-align: left;
    z-index: 2;
    pointer-events: none;  /* später für Interaktion entfernen */
  }
  .subline > span { display: inline-block; }

  .brand {
    color: var(--t1);
    /* BRAND-Größe: hier über CSS-Variablen steuerbar */
    /* globaler Typo-Faktor wirkt hier mit */
    font-size: calc(clamp(var(--brandMin), var(--brandVW), var(--brandMax)) * var(--typeScale));
  }

  .ai {
    position: absolute;
    left: 0; /* feste Referenz (Container: .hero) */
    top: 0;
    color: var(--t2);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.8s ease;
  }
  .ai.show { opacity: 1; }

  /* Gesamter Hero fadet ein */
  .hero.show { animation: fadeInHero 0.7s ease forwards; }
  @keyframes fadeInHero { to { opacity: 1; } }

  /* Mobile: BRAND etwas größer skalieren, um den Raum besser zu nutzen */
  @media (max-width: 600px) {
    :root {
      --brandMin: 3.6rem;
      --brandVW: 20vw; /* größerer vw-Faktor für Mobil */
      /* Subline-Mobile-Schriftgröße (anpassbar) */
      --subMobileMin: 0.6rem;
      --subMobileVW: 3.2vw;
      --subMobileMax: 0.85rem;
    }
    /* Subline auf Mobile kleiner, Abstände werden dadurch größer */
    .subline { font-size: calc(clamp(var(--subMobileMin), var(--subMobileVW), var(--subMobileMax)) * var(--typeScale)); }
  }
</style>
</head>
<body>
  <div class="hero" id="hero">
    <p class="tagline" id="tagline">SHAPE YOUR BRAND</p>
    <h1 class="text-layer brand" id="brand">BRAND<span id="ai" class="ai">AI</span></h1>
    <!-- SUBLINE:
         • Begriffe direkt in den <span>-Tags ändern.
         • Mindestabstand zwischen Items: :root --subMinGap
         • Laufweite (Buchstaben): :root --subTracking
         • Immer eine Zeile; Breite wird per JS exakt an BRAND-Text angepasst. -->
    <p class="subline" id="subline" aria-label="BRANDSTRATEGY BRANDDESIGN AI-WORKFLOW">
      <span data-key="strategy">BRANDSTRATEGY</span>
      <span data-key="design">BRANDDESIGN</span>
      <span data-key="ai">AI&#8209;WORKFLOW</span>
    </p>
  </div>

<script>
  (function() {
    const brand = document.getElementById('brand');
    const ai = document.getElementById('ai');
    const tagline = document.getElementById('tagline');
    const subline = document.getElementById('subline');
    const hero = document.getElementById('hero');

    /* Skaliert BRAND auf kleinen Screens auf ~96% der Hero-Breite, ohne zu bluten. */
    /*
     sizeBrandTo(ratio)
     - Nur Mobile: skaliert BRAND auf ~ratio der verfügbaren Breite.
     - Verhindert "Bluten" nach rechts.
     - Greift NICHT auf Desktop; Desktop-Größe kommt aus CSS clamp() Variablen.
  */
    function sizeBrandTo(ratio = 0.96) {
      const isSmall = window.matchMedia('(max-width: 600px)').matches;
      if (!isSmall) { brand.style.fontSize = ''; return; }
      const heroRect = hero.getBoundingClientRect();
      if (!heroRect.width) return;
      // Reset auf CSS-Size, messen, dann zielgerichtet skalieren
      brand.style.fontSize = '';
      const cs = getComputedStyle(brand);
      const fs = parseFloat(cs.fontSize) || 1;
      const currentWidth = brand.getBoundingClientRect().width || 1;
      const target = heroRect.width * ratio;
      const newSize = fs * (target / currentWidth);
      brand.style.fontSize = newSize + 'px';
    }

    /*
     alignPositions()
     - Liest CSS-Variablen (Offsets) und richtet AI/Tagline/Subline absolut aus.
     - AI: deckungsgleich auf das A von BRAND.
     - Subline: eine Zeile; RECHTE Kante bleibt konstant, wenn nach rechts geschoben wird.
     - Breite Subline: Mobile = 100% BRAND-Text, Desktop = Faktor (:root --subWidthFactor).
  */
    function alignPositions() {
      const cs = getComputedStyle(brand);
      ai.style.fontSize = cs.fontSize;
      ai.style.letterSpacing = cs.letterSpacing;
      ai.style.lineHeight = cs.lineHeight;
      ai.style.fontWeight = cs.fontWeight;

      const textNode = brand.firstChild;
      const indexA = brand.textContent.indexOf('A');
      if (indexA === -1) return;

      const range = document.createRange();
      range.setStart(textNode, indexA);
      range.setEnd(textNode, indexA + 1);

      const aRect = range.getBoundingClientRect();
      const heroRect = hero.getBoundingClientRect();
      const brandRect = brand.getBoundingClientRect();

      const fs = parseFloat(cs.fontSize) || 1;
      const rootCS = getComputedStyle(document.documentElement);
      const offX = (parseFloat(rootCS.getPropertyValue('--aiOffsetX')) || 0) * fs;
      const offY = (parseFloat(rootCS.getPropertyValue('--aiOffsetY')) || 0) * fs;
      ai.style.left = (aRect.left - heroRect.left + offX) + 'px';
      ai.style.top  = (aRect.top  - heroRect.top  + offY) + 'px';

      const tagOffX = (parseFloat(rootCS.getPropertyValue('--tagOffsetX')) || 0) * fs;
      const tagOffY = (parseFloat(rootCS.getPropertyValue('--tagOffsetY')) || 0) * fs;
      const tagRect = tagline.getBoundingClientRect();
      tagline.style.left = (brandRect.left - heroRect.left + tagOffX) + 'px';
      tagline.style.top  = (brandRect.top  - heroRect.top  - tagRect.height + tagOffY) + 'px';

      const subOffX = (parseFloat(rootCS.getPropertyValue('--subOffsetX')) || 0) * fs;
      const subOffY = (parseFloat(rootCS.getPropertyValue('--subOffsetY')) || 0) * fs;

      // Breite & linke Kante der reinen Text-Glyphen von "BRAND" ermitteln (ohne Einfluss des AI-Spans)
      // BRAND-Text-Bounding-Box (ohne den AI-Span) ermitteln
      const fullRange = document.createRange();
      fullRange.setStart(textNode, 0);
      fullRange.setEnd(textNode, textNode.length);
      const textRect = fullRange.getBoundingClientRect();

      // Subline an Text-Links ausrichten; Breite so berechnen, dass der RECHTE Rand konstant bleibt
      const isSmall = window.matchMedia('(max-width: 600px)').matches;
      // Desktop-Anteil der Subline-Breite relativ zur BRAND-Textbreite
      const factor = isSmall ? 1 : (parseFloat(rootCS.getPropertyValue('--subWidthFactor')) || 1);

      const left0 = textRect.left;
      const right0 = textRect.right; // fixierter rechter Rand
      const baseWidth = (right0 - left0) * Math.max(0, Math.min(1, factor));

      // Linke Kante verschieben; rechte Kante bleibt fix (kein Überlaufen)
      const newLeft = left0 + subOffX;        // nach rechts verschieben
      const newWidth = Math.max(0, Math.round(baseWidth - subOffX)); // rechte Kante bleibt

      subline.style.left = (newLeft - heroRect.left) + 'px';
      subline.style.top  = (brandRect.bottom - heroRect.top + subOffY) + 'px';
      subline.style.whiteSpace = 'nowrap';
      subline.style.maxWidth = '';
      subline.style.boxSizing = 'border-box';
      subline.style.width = newWidth + 'px';
    }

    function alignAll() {
      sizeBrandTo(0.96); // Mobile: füllt den verfügbaren Raum
      alignPositions();  // danach AI/Tag/Subline exakt positionieren
    }

    function init() {
      alignAll();
      // einfache Tests/Asserts zur Sicherheit (Konsole)
      setTimeout(() => {
        try {
          const tn = brand.firstChild;
          const r = document.createRange(); r.setStart(tn,0); r.setEnd(tn, tn.length);
          const brandTextWidth = Math.round(r.getBoundingClientRect().width);
          const subW = Math.round(subline.getBoundingClientRect().width);
          console.assert(Math.abs(brandTextWidth - subW) <= 1, 'Subline width != BRAND text width', {brandTextWidth, subW});
          console.assert(subline.scrollHeight <= parseFloat(getComputedStyle(subline).lineHeight) * 1.5, 'Subline wrapped to multiple lines');
        } catch(e) { console.warn('Self-test skipped', e); }
      }, 100);
      hero.classList.add('show');
      setTimeout(() => ai.classList.add('show'), 1400);
    }

    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(init);
    } else {
      window.addEventListener('load', init);
    }
    window.addEventListener('resize', alignAll);

    const ro = new ResizeObserver(alignAll);
    ro.observe(hero);
  })();
</script>
</body>
</html>
